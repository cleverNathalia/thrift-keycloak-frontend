"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Core = require("@creditkarma/thrift-server-core");
const request = require("request");
const utils_1 = require("./utils");
exports.DEFAULT_PATH = '/thrift';
function shouldRetry(response, retry, withEndpointPerMethod) {
    return (withEndpointPerMethod &&
        response !== undefined &&
        response !== null &&
        response.statusCode !== undefined &&
        response.statusCode === 404 &&
        retry === false);
}
function hasError(err) {
    return err !== undefined && err !== null;
}
function isErrorResponse(response) {
    return (response.statusCode !== null &&
        response.statusCode !== undefined &&
        (response.statusCode < 200 || response.statusCode > 299));
}
function filterHeaders(options, blacklist) {
    options.headers = options.headers || {};
    blacklist = blacklist.map((next) => next.toLocaleLowerCase());
    options.headers = Object.keys(options.headers).reduce((acc, next) => {
        if (blacklist.indexOf(next.toLocaleLowerCase()) === -1) {
            acc[next] = options.headers[next];
        }
        return acc;
    }, {});
    return options;
}
function applyFilters(currentRequest, filters, callback) {
    const [head, ...tail] = filters;
    if (head === undefined) {
        return callback(currentRequest);
    }
    else {
        return head(currentRequest, (nextData, nextOptions) => {
            const data = nextData !== undefined ? nextData : currentRequest.data;
            return applyFilters({
                data,
                methodName: currentRequest.methodName,
                uri: currentRequest.uri,
                context: Core.deepMerge(currentRequest.context, nextOptions || {}),
            }, tail, callback);
        });
    }
}
class HttpConnection extends Core.ThriftConnection {
    constructor({ hostName, port, path = '/thrift', https = false, transport = 'buffered', protocol = 'binary', requestOptions = {}, serviceName, withEndpointPerMethod = false, headerBlacklist = [], }) {
        super(Core.getTransport(transport), Core.getProtocol(protocol));
        this.requestOptions = Object.freeze(filterHeaders(requestOptions, headerBlacklist));
        this.port = port;
        this.hostName = hostName;
        this.path = Core.normalizePath(path || exports.DEFAULT_PATH);
        this.protocol = https === true ? 'https' : 'http';
        this.serviceName = serviceName;
        this.basePath = `${this.protocol}://${this.hostName}:${this.port}`;
        this.withEndpointPerMethod = withEndpointPerMethod;
        this.url = `${this.basePath}${this.path}`;
        this.filters = [];
    }
    register(...filters) {
        filters.forEach((next) => {
            this.filters.push({
                methods: next.methods || [],
                handler: next.handler,
            });
        });
    }
    send(dataToSend, context = {}) {
        const requestMethod = Core.readThriftMethod(dataToSend, this.Transport, this.Protocol);
        const filters = this.filtersForMethod(requestMethod);
        const thriftRequest = {
            data: dataToSend,
            methodName: requestMethod,
            uri: this.url,
            context,
        };
        return applyFilters(thriftRequest, filters, (finalRequest) => {
            return this.write(finalRequest.data, finalRequest.methodName, finalRequest.context);
        }).then((res) => {
            return res.body;
        });
    }
    write(dataToWrite, methodName, options = {}, retry = false) {
        const requestUrl = this.withEndpointPerMethod && retry === false
            ? `${this.url}/${this.serviceName}/${methodName}`
            : this.url;
        const requestOptions = Core.overlayObjects(this.requestOptions, options, {
            method: 'POST',
            body: dataToWrite,
            encoding: null,
            url: requestUrl,
            headers: {
                'Content-Length': dataToWrite.length,
                'Content-Type': 'application/octet-stream',
            },
        });
        return new Promise((resolve, reject) => {
            request(requestOptions, (err, response, body) => {
                if (shouldRetry(response, retry, this.withEndpointPerMethod)) {
                    resolve(this.write(dataToWrite, methodName, options, true));
                }
                else {
                    if (hasError(err)) {
                        reject(err);
                    }
                    else if (isErrorResponse(response)) {
                        reject(response);
                    }
                    else {
                        resolve({
                            statusCode: response.statusCode,
                            headers: response.headers,
                            body,
                        });
                    }
                }
            });
        });
    }
    filtersForMethod(name) {
        return this.filters
            .filter(utils_1.filterByMethod(name))
            .map((filter) => filter.handler);
    }
}
exports.HttpConnection = HttpConnection;
//# sourceMappingURL=HttpConnection.js.map