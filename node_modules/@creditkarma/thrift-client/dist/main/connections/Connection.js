"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const thrift_server_core_1 = require("@creditkarma/thrift-server-core");
const net = require("net");
const logger_1 = require("../logger");
const skipStruct = (buffer, Transport, Protocol) => {
    try {
        const transport = new Transport(buffer);
        const input = new Protocol(transport);
        input.readStructBegin();
        while (true) {
            const ret = input.readFieldBegin();
            const fieldType = ret.fieldType;
            if (fieldType === thrift_server_core_1.TType.STOP) {
                break;
            }
            else {
                input.skip(fieldType);
                input.readFieldEnd();
            }
        }
        input.readStructEnd();
        return transport.remaining();
    }
    catch (err) {
        return buffer;
    }
};
const createSocket = (config, logger) => {
    return new Promise((resolve, reject) => {
        const removeHandlers = () => {
            socket.removeAllListeners();
        };
        const connectHandler = () => {
            logger(['debug', 'Connection'], `Connected to: ${config.hostName}:${config.port}`);
            removeHandlers();
            resolve(socket);
        };
        const timeoutHandler = () => {
            logger(['error', 'Connection'], `Timed out connecting: ${config.hostName}:${config.port}`);
            removeHandlers();
            socket.destroy();
            reject(new Error('Timed out connecting'));
        };
        const errorHandler = (err) => {
            logger(['error', 'Connection'], `Error connecting: ${config.hostName}:${config.port}`);
            removeHandlers();
            socket.destroy();
            reject(err);
        };
        const socket = new net.Socket();
        socket.setTimeout(config.timeout || 5000);
        socket.once('error', errorHandler);
        socket.once('timeout', timeoutHandler);
        socket.once('connect', connectHandler);
        socket.connect(config.port, config.hostName);
    });
};
class Connection {
    constructor(socket, logger) {
        this._hasSession = false;
        this.logger = logger;
        this.socket = socket;
        this.frameCodec = new thrift_server_core_1.ThriftFrameCodec();
        this.initializeSocket();
    }
    hasSession() {
        return this._hasSession;
    }
    async destroy() {
        this.socket.destroy();
    }
    send(dataToSend, Transport, Protocol) {
        return new Promise((resolve, reject) => {
            let saved = Buffer.alloc(0);
            const removeHandlers = () => {
                this.socket.removeListener('data', dataHandler);
                this.socket.removeListener('end', endHandler);
                this.socket.removeListener('error', errorHandler);
                this.socket.removeListener('timeout', timeoutHandler);
            };
            const timeoutHandler = () => {
                removeHandlers();
                reject(new Error('Thrift connection timed out'));
            };
            const endHandler = () => {
                removeHandlers();
                reject(new Error('Thrift connection ended'));
            };
            const errorHandler = (err) => {
                this.logger(['error', 'Connection', 'send'], `Error sending data to thrift service: ${err.message}`);
                removeHandlers();
                reject(new Error('Thrift connection error'));
            };
            const dataHandler = (chunk) => {
                saved = Buffer.concat([saved, chunk]);
                const buffer = this.frameCodec.decode(saved);
                const stripped = skipStruct(buffer, Transport, Protocol);
                try {
                    const input = new Protocol(new Transport(stripped));
                    input.readMessageBegin();
                    while (true) {
                        const ret = input.readFieldBegin();
                        const fieldType = ret.fieldType;
                        if (fieldType === thrift_server_core_1.TType.STOP) {
                            removeHandlers();
                            resolve(buffer);
                            break;
                        }
                        else {
                            input.skip(fieldType);
                        }
                    }
                }
                catch (err) {
                    if (!(err instanceof thrift_server_core_1.InputBufferUnderrunError)) {
                        this.logger(['error', 'Connection', 'send', 'dataHandler'], `Error reading data from connection: ${err.message}`);
                        removeHandlers();
                        reject(err);
                    }
                }
            };
            this.socket.on('data', dataHandler);
            this.socket.once('end', endHandler);
            this.socket.once('error', errorHandler);
            this.socket.once('timeout', timeoutHandler);
            this.socket.write(this.frameCodec.encode(dataToSend));
        });
    }
    initializeSocket() {
        this.socket.on('close', () => {
            this._hasSession = false;
        });
        this.socket.on('end', () => {
            this._hasSession = false;
        });
        this.socket.on('timeout', () => {
            this.socket.end();
            this._hasSession = false;
        });
        this._hasSession = true;
    }
}
exports.Connection = Connection;
exports.createConnection = (config, logger = logger_1.defaultLogger) => createSocket(config, logger).then((socket) => {
    return new Connection(socket, logger);
});
//# sourceMappingURL=Connection.js.map